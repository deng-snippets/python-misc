-- ───────────────────────────────────────────────────────────────────
-- New tt_segs CTE – works on the WIDE table
-- ───────────────────────────────────────────────────────────────────
, tt_segs AS (
  /*  Still one row per TomTom-segment-per-15-minute-slice.
      We explode the 4-slot “_15m” arrays and keep the offset
      so every metric lines up by position.  */
  SELECT
    z.zone_id,
    z.is_reversed,

    -- rebuild the true 15-minute timestamp in LOCAL time
    TIMESTAMP(
      DATETIME(
        TIMESTAMP_ADD(a.dateHour, INTERVAL off * 15 MINUTE),   -- UTC → UTC+offset
        z.zone_tz                                             -- then shift to zone time
      )
    )                             AS local_time,

    /* static from/to filters exactly as before -- now evaluated
       on the exploded 15-min timestamps */
    CASE
      WHEN TIMESTAMP(
             DATETIME(
               TIMESTAMP_ADD(a.dateHour, INTERVAL off * 15 MINUTE),
               z.zone_tz
             )
           )
           BETWEEN TIMESTAMP '2025-01-01 00:00:00'
           AND     TIMESTAMP_ADD(TIMESTAMP '2025-01-31 00:00:00', INTERVAL 1 DAY)
      THEN '2025-01-01' END       AS from_date,
    CASE
      WHEN TIMESTAMP(
             DATETIME(
               TIMESTAMP_ADD(a.dateHour, INTERVAL off * 15 MINUTE),
               z.zone_tz
             )
           )
           BETWEEN TIMESTAMP '2025-01-01 00:00:00'
           AND     TIMESTAMP_ADD(TIMESTAMP '2025-01-31 00:00:00', INTERVAL 1 DAY)
      THEN '2025-01-31' END       AS to_date,

    UPPER(
      FORMAT_DATETIME('%a',
        DATE(
          TIMESTAMP(
            DATETIME(
              TIMESTAMP_ADD(a.dateHour, INTERVAL off * 15 MINUTE),
              z.zone_tz
            )
          )
        )
      )
    )                             AS dayofweek,

    /* compact “day-part” key: 0–95 (4 * hour + quarter-hour offset) */
    4 * EXTRACT(HOUR FROM TIMESTAMP(DATETIME(TIMESTAMP_ADD(a.dateHour, INTERVAL off * 15 MINUTE), z.zone_tz)))
        + off                     AS from_15m,

    /* ───────── metrics ───────── */
    z.tt_seg_weight * s.val       AS weighted_samplesize,

    a.avgSpeed_15m[OFFSET(off)].val  / 1609.34                   AS avg_speed_mph,

    -- convert the 19-percentile array for this quarter-hour slice
    tomtom.arrayMetersToMiles(
      a.speedPercentiles_15m[OFFSET(off)].percentiles
    )                                                          AS sp,

    /* 5th/95th extrapolated bounds in mph (same formula, new path) */
    CASE
      WHEN ARRAY_LENGTH(a.speedPercentiles_15m[OFFSET(off)].percentiles) = 0
      THEN NULL
      ELSE CAST(
        GREATEST(
          0,
          (
            a.speedPercentiles_15m[OFFSET(off)].percentiles[SAFE_OFFSET(0)]
            - 1.2 * (
              a.speedPercentiles_15m[OFFSET(off)].percentiles[SAFE_OFFSET(1)]
              - a.speedPercentiles_15m[OFFSET(off)].percentiles[SAFE_OFFSET(0)]
            )
          )
        )
        / 1609.34
        AS INT64
      )
    END                                                        AS min_value,

    CASE
      WHEN ARRAY_LENGTH(a.speedPercentiles_15m[OFFSET(off)].percentiles) = 0
      THEN NULL
      ELSE CAST(
        (
          a.speedPercentiles_15m[OFFSET(off)].percentiles[SAFE_OFFSET(18)]
          + 1.2 * (
            a.speedPercentiles_15m[OFFSET(off)].percentiles[SAFE_OFFSET(18)]
            - a.speedPercentiles_15m[OFFSET(off)].percentiles[SAFE_OFFSET(17)]
          )
        )
        / 1609.34
        AS INT64
      )
    END                                                        AS max_value

  FROM
    `stl-datascience.tomtom.tt_bulk_test_geohash6_wide_full` AS a
  JOIN
    mapped_zones z
  ON  a.geohash = z.tt_geohash6
  AND a.dsegId  = SAFE_CAST(z.tt_dsegid AS INT64)

  /*  Explode the hour-wide row into 4 quarter-hour slices.  
      Use the sample-size array as the anchor so every slice has a
      pre-computed sampleSize (s.val).  */
  CROSS JOIN
    UNNEST(a.sampleSize_15m) AS s WITH OFFSET off
  /* off ∈ {0,1,2,3}; s.val may be NULL → allowed, per your spec */
  WHERE
    a.dateHour BETWEEN TIMESTAMP '2025-01-01 00:00:00'
                   AND     TIMESTAMP '2025-01-31 00:00:00'
)

-- ───────────────────────────────────────────────────────────────
-- Everything that follows (midpoint-resampling, zone-level
-- aggregation, final select) is *identical* to the original script.
-- ───────────────────────────────────────────────────────────────
